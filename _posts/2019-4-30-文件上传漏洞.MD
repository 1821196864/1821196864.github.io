---
layout:     post
title:      文件上传漏洞整理
subtitle:   个人总结
date:       2019-4-20
author:     k
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - Blog
---

> 走先人的路，后人少走路。

# 前言   大神勿喷,小弟新人

文件上传漏洞整理:
  
原理:

在文件上传的功能处，若服务端脚本语言未对上传的文件进行严格验证和过滤，导致恶意用户上传恶意的脚本文件时，就有可能获取执行服务端命令的能力，这就是文件上传漏洞。
![](https://s2.ax1x.com/2019/04/24/EZ880I.png)
  
   
   上传检测流程概述:
        上传的方法有五种:基于前端的(js),基于后端的文件类型,文件扩展名,文件储存路径和文件内容.上传漏洞就是利用这五种上传过滤不严谨的条件实现的
![](https://s2.ax1x.com/2019/04/24/EZ8ttf.png)
   
   
     
一.绕过前端(js)检测

      方法:1.关闭前端js
           2.使用代理上传  如Burp Suite

![](https://s2.ax1x.com/2019/04/24/EZ8d1g.md.png)

二.绕过文件类型检测

     方法:使用bp抓包修改文件类型绕过
     
![](https://s2.ax1x.com/2019/04/24/EZ8a9S.png)
   
   
   
三.文件扩展名检测

绕过黑名单:

 方法:
 
1. 文件名大小写绕过 

     用像 AsP，pHp 之类的文件名绕过黑名单检测
            
2. 名单列表绕过

     用黑名单里没有的名单进行攻击，比如黑名单里没有 asa 或 cer 之类
        
3. 特殊文件名绕过 

     比如发送的 http 包里把文件名改成 test.asp. 或 test.asp_(下划线为空格)，这种命名方式 在 windows 系统里是不被允许的，所以需要在 burp 之类里进行修改，然后绕过验证后，会 被 windows 系统自动去掉后面的点和空格，但要注意 Unix/Linux 系统没有这个特性
        
4.0x00截断绕过

    在扩展名检测这一块目前我只遇到过 asp 的程序有这种漏洞，给个简单的伪代码name=getname(httprequest)//假如这时候获取到的文件名是 test.asp0x00.jpg(asp 后面为 0x00)type=gettype(name) //而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 jpg if(type == jpg)SaveFileToPath(UploadPath.name,name)//但在这里却是以 0x00 作为文件名截断 //最后以 test.asp 存入路径里
   
5..htaccess 文件攻击 

    配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测
      

     
   
              
             
白名单检查:

    白名单相对来说比黑名单安全一些，但也不见得就绝对安全了
         
绕过方法:

1.0x00 截断
 
     绕过用像 test.asp%00.jpg 的方式进行截断，属于白名单文件，再利用服务端代码的检测逻辑 漏洞进行攻击，目前我只遇到过 asp 的程序有这种漏洞 
     

2.解析调用/漏洞绕过

    这类漏洞直接配合上传一个代码注入过的白名单文件即可，再利用解析调用/漏洞
    
  
  
四.文件储存路径检测
  
![](https://s2.ax1x.com/2019/04/24/EZ8Nh8.md.png)

目录路径检测，一般就检测路径是否合法，但稍微特殊一点的都没有防御。 比如比较新的 fckeditorphp<= 2.6.4 任意文件上传漏洞漏洞成因是因为对目录路径的检测不够严谨而导致可以用 0x00 截断进行攻击 
   
 绕过方法:使用截断上传
 

 
 五.文件内容检测
 
  我们这里主要以最常见的图像类型内容检测来举例 文件幻数检查
  
  主要是检测文件内容开始处的文件幻数，比如图片类型的文件幻数如下
    
![](https://s2.ax1x.com/2019/04/24/EZ8G7t.md.png)

然后在文件幻数后面加上自己的一句话木马代码就行了




文件相关信息检查
       图像文件相关信息检测常用的就是 getimagesize()函数 只需要把文件头部分伪造好就 ok 了，就是在幻数的基础上还加了一些文件信息 有点像下面的结构
     
![](https://s2.ax1x.com/2019/04/24/EZ8YAP.md.png)



最后在加一个

  文件加载检查
  
      这个是最变态的检测了，一般是调用 API 或函数去进行文件加载测试 常见的是图像渲染测试，再变态点的甚至是进行二次渲染
      对渲染/加载测试的攻击方式是代码注入绕过 对二次渲染的攻击方式是攻击文件加载器自身
      先说下对渲染/加载测试攻击 - 代码注入绕过 可以用图像处理软件对一张图片进行代码注入 用 winhex 看数据可以分析出这类工具的原理是 在不破坏文件本身的渲染情况下找一个空白区进行填充代码，一般会是图片的注释区 对于渲染测试基本上都能绕过，毕竟本身的文件结构是完整的
      但如果碰到变态的二次渲染 基本上就没法绕过了，估计就只能对文件加载器进行攻击了. 
  














